<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>modules&#x2F;smethlib&#x2F;SMETHUtils.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/SMETHAcknowledgementController.html">SMETHAcknowledgementController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHAcknowledgementPreferencesController.html">SMETHAcknowledgementPreferencesController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHAddressBookController.html">SMETHAddressBookController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHAdvancedPreferencesController.html">SMETHAdvancedPreferencesController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHAttachmentController.html">SMETHAttachmentController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHAutomaticAcknowledgementController.html">SMETHAutomaticAcknowledgementController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHBankPreferencesController.html">SMETHBankPreferencesController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHComposeMessageController.html">SMETHComposeMessageController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHControlFactory.html">SMETHControlFactory</a></li>
            
                <li><a href="..&#x2F;classes/SMETHExportController.html">SMETHExportController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHHeaderController.html">SMETHHeaderController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHMail.html">SMETHMail</a></li>
            
                <li><a href="..&#x2F;classes/SMETHMailPreferencesController.html">SMETHMailPreferencesController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHMessageHandler.html">SMETHMessageHandler</a></li>
            
                <li><a href="..&#x2F;classes/SMETHMessageListController.html">SMETHMessageListController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHOptionController.html">SMETHOptionController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHRawContentController.html">SMETHRawContentController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHReadMessageController.html">SMETHReadMessageController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHReportController.html">SMETHReportController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHRequestController.html">SMETHRequestController</a></li>
            
                <li><a href="..&#x2F;classes/SMETHUtils.html">SMETHUtils</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/smeth.html">smeth</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: modules&#x2F;smethlib&#x2F;SMETHUtils.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;* ***** BEGIN LICENSE BLOCK *****
 * This file is part of smeth (https:&#x2F;&#x2F;code.google.com&#x2F;p&#x2F;sepamail-smeth&#x2F;)
 *
 * Version: MPL 2.0&#x2F;GPL 3.0&#x2F;LGPL 3.0
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http:&#x2F;&#x2F;www.mozilla.org&#x2F;MPL&#x2F;2.0&#x2F;
 *
 * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initials Developers of the Original Code are :
 *  Ammit Heeramun, idSoft
 *  Bishan Kumar Madhoo, idSoft
 *  Manfred Sherlock Olm, deciBI &amp; vizGet
 * Portions created by the Initials Developers are Copyright (C) 2012
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *  Ammit Heeramun
 *  Bishan Kumar Madhoo
 *  Manfred Sherlock Olm, smeth@decibi.fr
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 3 or later (the &quot;GPL&quot;), or
 * the GNU Lesser General Public License Version 3.0 or later (the &quot;LGPL&quot;),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** *&#x2F;

&#x2F;**
 * @module smeth
 * @file SMETHUtils.js
 * @version 1212ou
 * @since 1210
 * @author Ammit Heeramun
 * @description some tools for all smeth classes
 *&#x2F;

&#x2F;**
 * The FileUtils.jsm JavaScript code module offers utility routines dealing with files.
 *
 * @include FileUtils.jsm
 * @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Mozilla&#x2F;JavaScript_code_modules&#x2F;FileUtils.jsm
 * @type {Object}
 *&#x2F;
Components.utils.import(&quot;resource:&#x2F;&#x2F;gre&#x2F;modules&#x2F;FileUtils.jsm&quot;);

&#x2F;**
 * The NetUtil.jsm JavaScript code module provides easy-to-use APIs for performing common network related tasks.
 *
 * @include NetUtil.jsm
 * @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Mozilla&#x2F;JavaScript_code_modules&#x2F;NetUtil.jsm
 * @type {Object}
 *&#x2F;
Components.utils.import(&quot;resource:&#x2F;&#x2F;gre&#x2F;modules&#x2F;NetUtil.jsm&quot;);

&#x2F;**
 * SMETHMessageHandler class contain functions to handle info, error, warning and exceptions messages
 *
 * @include SMETHMessageHandler.js
 * @type {Object}
 *&#x2F;
Components.utils.import(&quot;resource:&#x2F;&#x2F;smeth&#x2F;smethlib&#x2F;SMETHMessageHandler.js&quot;);

&#x2F;**
 * items exported from the module
 * @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;JavaScript_code_modules&#x2F;Using
 * @type {Array}
 *&#x2F;
var EXPORTED_SYMBOLS = [&quot;SMETHUtils&quot;];

&#x2F;**
 * Strict mode for scripts
 * @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;JavaScript&#x2F;Reference&#x2F;Functions_and_function_scope&#x2F;Strict_mode
 *&#x2F;
&quot;use strict&quot;;

&#x2F;**
 * SMETHUtils contains all the useful functions that will be used in Smeth
 *
 * @class SMETHUtils
 *&#x2F;
SMETHUtils = function(aWindow) {

    this._window = aWindow;

    &#x2F;**
     * Message bundle for localised messages
     *
     * @attribute messageBundle
     * @private
     * @default Object
     *&#x2F;
    this.messageBundle = {

        &#x2F;&#x2F; Initialise internationalisation component
        _bundle: Components.classes[&quot;@mozilla.org&#x2F;intl&#x2F;stringbundle;1&quot;]
                           .getService(Components.interfaces.nsIStringBundleService)
                           .createBundle(&quot;chrome:&#x2F;&#x2F;smeth&#x2F;locale&#x2F;smeth.properties&quot;),

        &#x2F;&#x2F; Get the localised message for the specified key
        getLocalisedMessage: function(key) {
            return this._bundle.GetStringFromName(key);
        }
    };

    this._smethMessageHandler = new SMETHMessageHandler(aWindow);

};

&#x2F;**
 * SMETHUtils class methods.
 *
 * @class SMETHUtils
 *&#x2F;
SMETHUtils.prototype = {

    &#x2F;**
     * Declare the smeth preferences class
     *
     * @attribute _smethPreferences
     * @private
     * @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Code_snippets&#x2F;Preferences#XPCOM_interfaces_for_preferences_system
     *&#x2F;
    _smethPreferences : Components.classes[&quot;@mozilla.org&#x2F;preferences-service;1&quot;]
                                  .getService(Components.interfaces.nsIPrefService)
                                  .getBranch(&quot;extensions.smeth.&quot;),

    &#x2F;**
     * Check if user is allowed to carry out EBICS upload for a given message type
     *
     * @method allowEbicsUpload
     * @param {String} messageType SEPAmail message type
     * @return Whether the user is allowed to upload file via EBICS
     *&#x2F;
    allowEbicsUpload : function(messageType) {

        &#x2F;&#x2F; Get list of message types for which EBICS file upload is allowed
        var ebicsUpload = JSON.parse(this._smethPreferences.getCharPref(&#x27;ebics.uploads&#x27;));

        &#x2F;&#x2F; Scan the list of message types
        for (var i = 0; i &lt; ebicsUpload.length; i++) {
            var currentMessageType = ebicsUpload[i];
            if (currentMessageType.type == messageType) {
                return true;
            }
        }

        return false;
    },

    &#x2F;**
     * checkTodayDate function checks if a date is today&#x27;s date
     *
     * @method checkTodayDate
     * @param {Date} aDate Object
     * @return {Boolean} true if aDate is today, else false
     * REM MSO 20121210 I prefer method name &quot;isToday&quot; and we can share a method getDateMidnight
     *&#x2F;
    checkTodayDate : function(aDate){

        try
        {
            &#x2F;&#x2F; Create date from input value
            var inputDate = new this._window.Date(aDate);

            &#x2F;&#x2F; Get today&#x27;s date
            &#x2F;&#x2F; We could use method now()
            var todaysDate = new this._window.Date();

            &#x2F;&#x2F; call setHours to take the time out of the comparison
            todaysDate.setHours(0,0,0,0);
            inputDate.setHours(0,0,0,0);

            if (todaysDate.valueOf() == inputDate.valueOf()) {
                return true;
            } else {
            	return false;
            }

        } catch(ex) {
            throw ex;
        }
    },

    &#x2F;**
     * Format a given date object in a SEPAmail date and time format
     *
     * @method formatDateForSEPAmail
     * @param {Date} date The date that needs to be formatted for a SEPAmail message
     * @return {String} Current date and time value in a SEPAmail valid format
     *&#x2F;
    formatDateForSEPAmail : function(date) {

        &#x2F;&#x2F; Formatted date and time value
        return date.getFullYear() + &#x27;-&#x27; +
            ((date.getMonth() + 1) &gt; 9 ? (date.getMonth() + 1) : (&#x27;0&#x27; + (date.getMonth() + 1))) + &#x27;-&#x27; +
            (date.getDate() &gt; 9 ? date.getDate() : (&#x27;0&#x27; + date.getDate())) + &#x27;T&#x27; +
            (date.getHours() &gt; 9 ? date.getHours() : (&#x27;0&#x27; + date.getHours())) + &#x27;:&#x27; +
            (date.getMinutes() &gt; 9 ? date.getMinutes() : (&#x27;0&#x27; + date.getMinutes())) + &#x27;:&#x27; +
            (date.getSeconds() &gt; 9 ? date.getSeconds() : (&#x27;0&#x27; + date.getSeconds()));
    },

    &#x2F;**
     * Freeze the given SEPAmail UI form to disable user interaction
     *
     * @method freezeContent
     * @param {XML} content XUL fragment which contains the SMETH UI
     *&#x2F;
    freezeContent : function(content) {

        &#x2F;&#x2F; Make all textboxes read-only
        var textboxes = content.getElementsByTagNameNS(&quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;,
            &quot;textbox&quot;);
        for (var i = 0; i &lt; textboxes.length; i++) {
            textboxes[i].readOnly = true;
        }

        &#x2F;&#x2F; Disable all buttons
        var buttons = content.getElementsByTagNameNS(&quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;,
            &quot;button&quot;);
        for (var j = 0; j &lt; buttons.length; j++) {
            buttons[j].disabled = true;
        }

        &#x2F;&#x2F; Make all list boxes read-only
        var listboxes = content.getElementsByTagNameNS(&quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;,
            &quot;listbox&quot;);
        for (var k = 0; k &lt; listboxes.length; k++) {
            listboxes[k].readOnly = true;
        }

        &#x2F;&#x2F; Make all date pickers read-only
        var datepickers = content.getElementsByTagNameNS(&quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;,
            &quot;datepicker&quot;);
        for (var l = 0; l &lt; datepickers.length; l++) {
            datepickers[l].readOnly = true;
        }
    },

    &#x2F;**
     * generateMessageId generates a unique message ID
     *
     * @method generateMessageId
     *&#x2F;
    generateMessageId : function() {

        &#x2F;&#x2F; UUID generator instance
        var uuidGenerator = Components.classes[&quot;@mozilla.org&#x2F;uuid-generator;1&quot;]
                                      .getService(Components.interfaces.nsIUUIDGenerator);

        return (uuidGenerator.generateUUID().toString().replace(&#x2F;-&#x2F;g, &quot;&quot;)).substring(1, 33).toUpperCase();
    },

    &#x2F;**
     * getAccountByFolder matches an email account to a given folder
     *
     * @method getAccountByFolder
     * @param {Object} aFolder Folder object
     * @return {Object} Account object
     *&#x2F;
    getAccountByFolder : function(aFolder) {

        try {

            &#x2F;&#x2F; Check if the folder object has been defined
            if (aFolder != null) {

                &#x2F;&#x2F; Account manager interface instance
                var accountManager = Components.classes[&quot;@mozilla.org&#x2F;messenger&#x2F;account-manager;1&quot;]
                                               .getService(Components.interfaces.nsIMsgAccountManager);

                &#x2F;&#x2F; List of registered accounts
                var accounts = accountManager.accounts;

                &#x2F;&#x2F; Scan the list of accounts
                for (var i = 0; i &lt; accounts.Count(); i++) {

                    &#x2F;&#x2F; Current account
                    var currentAccount = accounts.QueryElementAt(i, Components.interfaces.nsIMsgAccount);

                    &#x2F;&#x2F; Check if folder has the incomingServer property
                    if (currentAccount.incomingServer != undefined) {

                        &#x2F;&#x2F; Current account root folder
                        var rootFolder = currentAccount.incomingServer.rootFolder;

                        &#x2F;&#x2F; Check if the root folder has sub-folders
                        if (rootFolder.hasSubFolders) {

                            &#x2F;&#x2F; List of sub-folders
                            var subfolders = rootFolder.subFolders;

                            &#x2F;&#x2F; Scan the list of sub-folders and try to match the folder with the give folder
                            while (subfolders.hasMoreElements()) {

                                &#x2F;&#x2F; Check if the folders match
                                if (subfolders.getNext().QueryInterface(Components.interfaces.nsIMsgFolder)
                                    == aFolder) {
                                    return currentAccount;
                                }
                            }
                        }

                        &#x2F;&#x2F; Check if the root folder matches the given folder
                        if (rootFolder == aFolder) {
                            return currentAccount;
                        }
                    }
                }
            }

            &#x2F;&#x2F; No matching account could be found
            return null;

        } catch (ex) {
            throw ex;
        }
    },

    &#x2F;**
     * Get the account on which the email corresponding to the specified header was obtained
     *
     * @method getAccountByMsgHeader
     * @param {Object} aMsgHdr Message header
     * @return Get account on which the header of the corresponding email was obtained
     * @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Thunderbird&#x2F;Account_interfaces
     * @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Thunderbird&#x2F;Account_examples
     *&#x2F;
    getAccountByMsgHeader : function(aMsgHdr) {

        &#x2F;&#x2F; Obtain the accounted related to the message by using the folder in which the current message resides
        return this.getAccountByFolder(aMsgHdr.folder);
    },

    &#x2F;**
     * Get the XSL file name for managing attachments when composing a given message type
     *
     * @method getCompositionAttachmentTransformationForMessageType
     * @param {String} messageType Message type
     * @return {String} XSL file name for managing attachments when composing given message type
     *&#x2F;
    getCompositionAttachmentTransformationForMessageType : function(messageType) {

        &#x2F;&#x2F; Controller configuration
        var config = JSON.parse(this._smethPreferences.getCharPref(&#x27;controller.config&#x27;));

        &#x2F;&#x2F; Scan the list of settings
        for (var i = 0; i &lt; config.length; i++) {

            &#x2F;&#x2F; Check if we are at the required message type
            if (config[i].type == messageType) {
                if (config[i].settings.attachment.trim().length &gt; 0) {
                    return &quot;chrome:&#x2F;&#x2F;{appname}&#x2F;content&#x2F;xsl&#x2F;&quot; + config[i].settings.attachment.trim();
                } else {
                    return null;
                }
            }
        }

        return null;
    },

    &#x2F;**
     * Get the XSL file name for composing a given message type
     *
     * @method getCompositionTransformationForMessageType
     * @param {String} messageType Message type
     * @return {String} XSL file name for composing given message type
     *&#x2F;
    getCompositionTransformationForMessageType : function(messageType) {

        &#x2F;&#x2F; Controller configuration
        var config = JSON.parse(this._smethPreferences.getCharPref(&#x27;controller.config&#x27;));

        &#x2F;&#x2F; Scan the list of settings
        for (var i = 0; i &lt; config.length; i++) {

            &#x2F;&#x2F; Check if we are at the required message type
            if (config[i].type == messageType) {
                if (config[i].settings.composition.trim().length &gt; 0) {
                    return &quot;chrome:&#x2F;&#x2F;{appname}&#x2F;content&#x2F;xsl&#x2F;&quot; + config[i].settings.composition.trim();
                } else {
                    return null;
                }
            }
        }

        return null;
    },

    &#x2F;**
     * getControllerConfigObject function get the controllers config object as per the message type
     *
     * @method getControllerConfigObject
     * @param {String} aMessageType
     * @return {Object} Controller config object or null
     * REM MSO 20121210 if controllerConfigObject is an object, loop &quot;for&quot; is inappropriate
     * TODO rewrite this, dirty
     *&#x2F;
    getControllerConfigObject : function(aMessageType) {

        try {
            &#x2F;&#x2F; Register to receive notifications of preference changes
            var smethPreferences = Components.classes[&quot;@mozilla.org&#x2F;preferences-service;1&quot;]
                                    .getService(Components.interfaces.nsIPrefService)
                                    .getBranch(&quot;extensions.smeth.&quot;);

            smethPreferences.QueryInterface(Components.interfaces.nsIPrefBranch2);

            var controllerConfigObject = JSON.parse(smethPreferences.getCharPref(&quot;controller.config&quot;));

            for(var i = 0; i &lt; controllerConfigObject.length; i++)
            {
                if(aMessageType == controllerConfigObject[i].type)
                {
                    return controllerConfigObject[i];
                }
                else {}
            }

            return null;
        }
        catch(ex)
        {
            throw ex;
        }
    },

    &#x2F;**
     * Get the EBICS file format associated with a given SEPAmail message type
     *
     * @method getEBICSFileFormat
     * @param {String} messageType SEPAmail message type
     * @return EBICS file format
     *&#x2F;
    getEBICSFileFormat : function(messageType) {

        &#x2F;&#x2F; Get list of message types for which EBICS file upload is allowed
        var ebicsUpload = JSON.parse(this._smethPreferences.getCharPref(&#x27;ebics.uploads&#x27;));

        &#x2F;&#x2F; Scan the list of message types
        for (var i = 0; i &lt; ebicsUpload.length; i++) {
            var currentMessageType = ebicsUpload[i];
            if (currentMessageType.type == messageType) {
                return currentMessageType.format;
            }
        }

        return null;
    },

    &#x2F;**
     * getFile function opens the file picker, allows the user to select a file and returns a file object corresponding
     * to the user selection
     *
     * @method getFile
     * @param {String} title The title of the Open File dialog box
     * @return {Object} The file object corresponding to the user selected file
     *&#x2F;
    getFile : function(title) {

        try {

            &#x2F;&#x2F; Instantiate the nsIFilePicker
            const nsIFilePicker = Components.interfaces.nsIFilePicker;

            &#x2F;&#x2F; File picker instance
            var fp = Components.classes[&quot;@mozilla.org&#x2F;filepicker;1&quot;]
                               .createInstance(nsIFilePicker);
            fp.init(this._window, title , nsIFilePicker.modeOpen);

            &#x2F;&#x2F; Show the file picker
            var rv = fp.show();

            &#x2F;&#x2F; Check if user has chosen a file to attach
            if (rv == nsIFilePicker.returnOK || rv == nsIFilePicker.returnReplace) {

                &#x2F;&#x2F; Check if file exists
                if (false == fp.file.exists()) {
                    throw new Error(&quot;File could not be found.&quot;);
                }

                return fp.file;
            }

            return null

        } catch(ex) {
            throw(ex);
        }
    },

    &#x2F;**
     * Get the type of a given message folder
     *
     * @method getFolderType
     * @param {Object} folder Current message folder
     * @return Message folder type
     *&#x2F;
    getFolderType : function(folder) {

        &#x2F;&#x2F; Get the base message URI parts
        var baseMessageUriParts = folder.displayedFolder.baseMessageURI.split(&quot;&#x2F;&quot;);

        return baseMessageUriParts[baseMessageUriParts.length - 1].toUpperCase();
    },

    &#x2F;**
     * Get the Thunderbird mail account that corresponds to a give mail account alias - an alias can be the name
     * displayed for the mail account or the mail account name itself
     *
     * @method getMailAccountByAlias
     * @param {String} alias Mail account alias
     * @return Thunderbird mail account corresponding to the given alias
     *&#x2F;
    getMailAccountByAlias : function(alias) {

        &#x2F;&#x2F; Account manager interface instance
        var accountManager = Components.classes[&quot;@mozilla.org&#x2F;messenger&#x2F;account-manager;1&quot;]
                                       .getService(Components.interfaces.nsIMsgAccountManager);

        &#x2F;&#x2F; List of registered accounts
        var accounts = accountManager.accounts;

        &#x2F;&#x2F; Scan the list of accounts
        for (var i = 0; i &lt; accounts.Count(); i++) {

            &#x2F;&#x2F; Current account
            var currentAccount = accounts.QueryElementAt(i, Components.interfaces.nsIMsgAccount);

            &#x2F;&#x2F; Check if the defaultIdentity property has been defined the current account
            if (currentAccount.defaultIdentity != undefined) {

                &#x2F;&#x2F; Check the email address associated with the current account
                if ((currentAccount.defaultIdentity.email.trim().toLowerCase() == alias.trim().toLowerCase()) ||
                    (alias.trim().toLowerCase().indexOf(&#x27;&lt;&#x27; + currentAccount.defaultIdentity.email.trim().toLowerCase()
                        + &#x27;&gt;&#x27;) &gt; -1)) {
                    return currentAccount;
                }
            }
        }

        return null;
    },

    &#x2F;**
     * getMailBody recursive function get the message body from the message content parts parametered
     *
     * @method getMailBody
     * @param {Object} aMessageParts Object
     * @param {String} displayedMessage Message string being displayed in the message pane
     * @return {String} Message body String
     *&#x2F;
    getMailBody : function (aMessageParts, displayedMessage) {

        try {

            if (!aMessageParts) {

                &#x2F;&#x2F; If the part contains a body
                if(aMessageParts.body) {

                    &#x2F;&#x2F; Return the body
                    return aMessageParts.body;

                } else {

                    &#x2F;&#x2F; Call the getMessageBody function again
                    return this.getMailBody(aMessageParts.parts[0], displayedMessage);
                }

            } else {
                return displayedMessage;
            }

        } catch(ex) {
            throw ex;
        }
    },

    &#x2F;**
     * getMailContentFromParts recursively gets the message body from the given message content parts
     *
     * @method getMailContentFromParts
     * @param {Object} aMessagePart Message content parts
     * @param {String} defaultMessage Message string that is returned when mail content could not be determined from the given parts
     * @return {String} Message body String
     *&#x2F;
    getMailContentFromParts : function(aMessagePart, defaultMessage) {

        try {

            &#x2F;&#x2F; Check if message part has been defined
            if (aMessagePart != undefined) {

                &#x2F;&#x2F; Check if we have a body at the current message part node
                if (aMessagePart.body != undefined) {

                    &#x2F;&#x2F; Return the body of the message
                    return aMessagePart.body;

                } else {

                    &#x2F;&#x2F; Check if there are more parts in the current part
                    if (aMessagePart.parts != undefined) {

                        &#x2F;&#x2F; Check the length of the message parts
                        if (aMessagePart.parts.length &gt; 0) {

                            &#x2F;&#x2F; Call the function again with the new sub-part
                            return this.getMailContentFromParts(aMessagePart.parts[0], defaultMessage);

                        } else {

                            &#x2F;&#x2F; Return default message since message part is defined but does not contain any element
                            return defaultMessage;
                        }

                    } else {

                        &#x2F;&#x2F; Return default message since message part and body is not defined
                        return defaultMessage;
                    }
                }

            } else {

                &#x2F;&#x2F; Return default message since message part does not exist
                return defaultMessage;
            }

        } catch(ex) {
            throw ex;
        }
    },

    &#x2F;**
     * Get the message expiry duration
     *
     * @method getMessageExpiryDuration
     * @return {Object} Message expiry duration
     *&#x2F;
    getMessageExpiryDuration : function() {

        &#x2F;&#x2F; Get user defined message expiry duration string
        var durationStr = this._smethPreferences.getCharPref(&quot;expiryDuration&quot;);

        &#x2F;&#x2F; Check if expiry duration has been specified
        if (durationStr.length &gt; 1) {

            var intPart = &#x27;&#x27;;
            var strPart = &#x27;&#x27;;
            var duration = {years: 0, months: 0, days: 0};

            &#x2F;&#x2F; Try to parse the given duration string
            for (var i = 0; i &lt; durationStr.length; i++) {

                &#x2F;&#x2F; Check if the current character is a number
                if (isNaN(durationStr.charAt(i))) {

                    &#x2F;&#x2F; Get the period definition character
                    strPart = durationStr.charAt(i).toLowerCase();

                    &#x2F;&#x2F; Action based on period definition character
                    switch(strPart) {

                        case &#x27;y&#x27;:

                            &#x2F;&#x2F; Set the number of years in the expiry duration object
                            duration.years = parseInt(intPart, 10);

                            break;

                        case &#x27;m&#x27;:

                            &#x2F;&#x2F; Set the number of months in the expiry duration object
                            duration.months = parseInt(intPart, 10);

                            break;

                        case &#x27;d&#x27;:

                            &#x2F;&#x2F; Set the number of days in the expiry duration object
                            duration.days = parseInt(intPart, 10);

                            break;

                        default:

                            &#x2F;&#x2F; Return default duration since an invalid duration character was found
                            return {years: 0, months: 1, days: 0};
                    }

                    &#x2F;&#x2F; Check if we are at the end of the duration string
                    if (i == (durationStr.length - 1)) {
                        return duration;
                    } else {
                        intPart = &#x27;&#x27;;
                        strPart = &#x27;&#x27;;
                    }

                } else {

                    &#x2F;&#x2F; Concatenate the integer part
                    intPart += durationStr.charAt(i);
                }
            }
        }

        &#x2F;&#x2F; Default message expiry duration
        return {years: 0, months: 1, days: 0};
    },

    &#x2F;**
     * Check if a given message type has attachments
     *
     * @method getMessageTypeHasAttachments
     * @param {String} messageType Message type
     * @return {boolean} Whether the given message type has attachments
     *&#x2F;
    getMessageTypeHasAttachments : function(messageType) {

        &#x2F;&#x2F; Controller configuration
        var config = JSON.parse(this._smethPreferences.getCharPref(&#x27;controller.config&#x27;));

        &#x2F;&#x2F; Scan the list of settings
        for (var i = 0; i &lt; config.length; i++) {

            &#x2F;&#x2F; Check if we are at the required message type
            if (config[i].type == messageType) {
                return config[i].settings.hasAttachments;
            }
        }

        return false;
    },

    &#x2F;**
     * Get the mode associated to a given message type - defaults to test is message type cannot be found in the
     * configuration settings for ecosystems
     *
     * @method getMessageTypeMode
     * @param {String} messageType SEPAmail message type for which mode needs to be determined
     * @return Mode for given message type
     *&#x2F;
    getMessageTypeMode : function(messageType) {

        &#x2F;&#x2F; Ecosystem settings
        var ecosystemSettings = JSON.parse(this._smethPreferences.getCharPref(&#x27;ecosystems&#x27;));

        &#x2F;&#x2F; Traverse the list of ecosystem settings objects and find the required message type
        for (var i = 0; i &lt; ecosystemSettings.length; i++) {

            &#x2F;&#x2F; Traverse the list of messages for the current ecosystem settings
            for (var j = 0; j &lt; ecosystemSettings[i].messages.length; j++) {

                &#x2F;&#x2F; Check if we are at the required message type
                if (ecosystemSettings[i].messages[j] == messageType) {

                    &#x2F;&#x2F; Get the mode
                    return ecosystemSettings[i].mode;
                }
            }
        }

        return &#x27;test&#x27;;
    },

    &#x2F;**
     * Get the email account key to QXBAN association object
     *
     * @method getQxbanByEmailAddressAccount
     * @param {Object} account Account for which association object is required
     * @return {String} Email address account to QXBAN association object
     *&#x2F;
    getQxbanByEmailAddressAccount : function(account) {

        var qxbanConfig = JSON.parse(this._smethPreferences.getCharPref(&quot;myqxbans&quot;));

        &#x2F;&#x2F; Scan the array of email address account to QXBAN association objects
        for (var i = 0; i &lt; qxbanConfig.length; i++) {

            &#x2F;&#x2F; Current association object
            var currentItem = qxbanConfig[i];

            &#x2F;&#x2F; Check if we have the required object
            if (currentItem.account == account) {

                &#x2F;&#x2F; Check if QXBAN has been defined for the account
                if (currentItem.qxban.trim().length &gt; 0) {
                    return currentItem;
                } else {
                    break;
                }
            }
        }

        return null;
    },

    &#x2F;**
     * Get the QXBAN of a specified email address from the array of email address to QXBAN objects
     *
     * @method getReceiverQxbanByEmailAddress
     * @param {String} email Email address
     * @return {Object} QXBAN of email address in the array of email addresses to QXBAN objects
     *&#x2F;
    getReceiverQxbanByEmailAddress : function(email) {

        &#x2F;&#x2F; Regular expression for retrieving email address
        var emailRegEx = &#x2F;(([^&lt;&gt;()[\]\\.,;:\s@\&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@\&quot;]+)*)|(\&quot;.+\&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))&#x2F;;

        &#x2F;&#x2F; Retrieve the email address from the given email string
        var emailAddressMatches = email.match(emailRegEx);

        &#x2F;&#x2F; Check if a match for the email address was found
        if (emailAddressMatches != null) {

            &#x2F;&#x2F; Get address book manager instance
            var abManager = Components.classes[&quot;@mozilla.org&#x2F;abmanager;1&quot;]
                                      .getService(Components.interfaces.nsIAbManager);

            &#x2F;&#x2F; Directories of the address book
            var directories = abManager.directories;

            &#x2F;&#x2F; Scan the directories
            while (directories.hasMoreElements()) {

                &#x2F;&#x2F; Current address book directory
                var currentDirectory = directories.getNext().QueryInterface(Components.interfaces.nsIAbDirectory);

                &#x2F;&#x2F; Check the current directory instance
                if (currentDirectory instanceof Components.interfaces.nsIAbDirectory) {

                    &#x2F;&#x2F; Find the contact card with the given email address
                    var card = currentDirectory.cardForEmailAddress(emailAddressMatches[0]);

                    &#x2F;&#x2F; Check if a card was found
                    if (card != null) {

                        &#x2F;&#x2F; Return the SEPAmail account of the receiver
                        return card.getProperty(&quot;SMETHSEPAmailAccount&quot;, &#x27;&#x27;).trim().length &gt; 0 ?
                            {qxban : card.getProperty(&quot;SMETHSEPAmailAccount&quot;, &#x27;&#x27;).trim()} : null;
                    }
                }
            }
        }

        &#x2F;&#x2F; Item could not be found
        return null;
    },

    &#x2F;**
     * Get the SEPAmail message root node type for a given SEPAmail message string
     *
     * @method getSEPAmailMessageRootNodeType
     * @param @param {String} content Content of email
     * @return {String} SEPAmail message root node type
     *&#x2F;
    getSEPAmailMessageRootNodeType : function(content) {

        &#x2F;&#x2F; Check if content has been defined
        if (content != null) {

            try {

                &#x2F;&#x2F; DOM parser
                var parser = Components.classes[&quot;@mozilla.org&#x2F;xmlextras&#x2F;domparser;1&quot;]
                                       .createInstance(Components.interfaces.nsIDOMParser);

                &#x2F;&#x2F; Parse content to XML document object model
                var contentXmlDom = parser.parseFromString(content, &quot;text&#x2F;xml&quot;);

                &#x2F;&#x2F; Check if content is a valid XML
                if (contentXmlDom.documentElement.nodeName != &quot;parsererror&quot;) {

                    &#x2F;&#x2F; Valid SEPAmail message root node types
                    var rootNodes = this._smethPreferences.getCharPref(&quot;prefSEPAmailXMLTag&quot;).split(&quot;;&quot;);

                    &#x2F;&#x2F; Scan the list of valid XML root node tags
                    for (var i = 0; i &lt; rootNodes.length; i++) {

                        &#x2F;&#x2F; Content is valid XML, so we check if the message is a valid SEPAmail XML
                        var msgTypeNodeResult = contentXmlDom.evaluate(rootNodes[i], contentXmlDom, this.nsResolver,
                            9, null);

                        &#x2F;&#x2F; Check if result for query was obtained
                        if (msgTypeNodeResult != null) {

                            &#x2F;&#x2F; Check SEPAmail root node was obtained
                            if (msgTypeNodeResult.singleNodeValue != null) {
                                return rootNodes[i].split(&#x27;:&#x27;)[1].toLowerCase();
                            }
                        }
                    }
                }

            } catch (e) {
                throw e;
            }
        }

        return null;
    },

    &#x2F;**
     * Get the SEPAmail message type for a given SEPAmail XML document object model
     *
     * @method getSEPAmailMessageType
     * @param {XML} sepaMailXmlDom SEPAmail XML document object model
     * @return {String} SEPAmail message type
     *&#x2F;
    getSEPAmailMessageType : function(sepaMailXmlDom) {

        &#x2F;&#x2F; SEPAmail message type node
        var msgTypeNodeResult = sepaMailXmlDom.evaluate(this._smethPreferences.getCharPref(&quot;missive.prefMsgTypXpath&quot;),
            sepaMailXmlDom, this.nsResolver, 9, null);

        &#x2F;&#x2F; Check if SEPAmail message type node query returned a result
        if (msgTypeNodeResult != null) {

            &#x2F;&#x2F; Check if the SEPAmail message type node was found
            if (msgTypeNodeResult.singleNodeValue != null) {

                return msgTypeNodeResult.singleNodeValue.textContent;

            } else {

                &#x2F;&#x2F; SEPAmail message type node was not found - we could be handling a SEPAmail acknowledgement
                return &#x27;&#x27;;
            }

        } else {

            &#x2F;&#x2F; SEPAmail message type could not be determine
            return &#x27;&#x27;;
        }
    },

    &#x2F;**
     * Get the XML template file name for a given message type
     *
     * @method getTemplateForMessageType
     * @param {String} messageType Message type
     * @return {String} XML template file name for given message type
     *&#x2F;
    getTemplateForMessageType : function(messageType) {

        &#x2F;&#x2F; Controller configuration
        var config = JSON.parse(this._smethPreferences.getCharPref(&#x27;controller.config&#x27;));

        &#x2F;&#x2F; Scan the list of settings
        for (var i = 0; i &lt; config.length; i++) {

            &#x2F;&#x2F; Check if we are at the required message type
            if (config[i].type == messageType) {
                if (config[i].settings.template.trim().length &gt; 0) {
                    return &quot;chrome:&#x2F;&#x2F;{appname}&#x2F;content&#x2F;xml&#x2F;&quot; + config[i].settings.template.trim();
                } else {
                    return null;
                }
            }
        }

        return null;
    },

    &#x2F;**
     * Check if the content of a body contains a valid acknowledgement missive message
     *
     * @method isAcknowledgementMissiveMessage
     * @param {String} content Message content
     * @return {Boolean} Whether the message is a valid acknowledgement missive message
     *&#x2F;
    isAcknowledgementMissiveMessage : function(content) {

        try {

            &#x2F;&#x2F; Parse content to XML document object model
            var contentXmlDom = new DOMParser().parseFromString(content, &quot;text&#x2F;xml&quot;);

            &#x2F;&#x2F; Check if content is a valid XML
            if (contentXmlDom.documentElement.nodeName != &quot;parsererror&quot;) {

                &#x2F;&#x2F; Content is valid XML, so we check for message type
                var msgTypeNodeResult = contentXmlDom.evaluate(&quot;&#x2F;sem:Missive&#x2F;sem:sepamail_missive_001&#x2F;sem:MsvTyp&quot;,
                    contentXmlDom, this.nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);

                &#x2F;&#x2F; Check if result for message type query was obtained
                if (msgTypeNodeResult != null) {

                    &#x2F;&#x2F; Check the message type
                    if (msgTypeNodeResult.singleNodeValue.textContent == &#x27;Acquittement&#x27;) {
                        return true;
                    }
                }
            }

            return false;

        } catch (e) {
            this._smethMessageHandler.exception(e);
        }
    },

    &#x2F;**
     * Check if the content of an email is a SEPAmail message
     *
     * @method isSEPAmail
     * @param {String} content Content of email
     * @return {Boolean} Whether the content is a valid SEPAmail message
     *&#x2F;
    isSEPAmail : function(content) {

        &#x2F;&#x2F; Check if content has been defined
        if (content != null) {

            &#x2F;&#x2F; Check for XML declaration
            if (content.indexOf(&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#x27;) == 0) {

                try {

                    &#x2F;&#x2F; DOM parser
                    var parser = Components.classes[&quot;@mozilla.org&#x2F;xmlextras&#x2F;domparser;1&quot;]
                                           .createInstance(Components.interfaces.nsIDOMParser);

                    &#x2F;&#x2F; Parse content to XML document object model
                    var contentXmlDom = parser.parseFromString(content, &quot;application&#x2F;xml&quot;);

                    &#x2F;&#x2F; Check if content is a valid XML
                    if (contentXmlDom.documentElement.nodeName != &quot;parsererror&quot;) {

                        &#x2F;&#x2F; Valid SEPAmail message root node types
                        var rootNodes = this._smethPreferences.getCharPref(&quot;prefSEPAmailXMLTag&quot;).split(&quot;;&quot;);

                        &#x2F;&#x2F; Scan the list of valid XML root node tags
                        for (var i = 0; i &lt; rootNodes.length; i++) {

                            &#x2F;&#x2F; Content is valid XML, so we check if the message is a valid SEPAmail XML
                            var msgTypeNodeResult = contentXmlDom.evaluate(rootNodes[i], contentXmlDom, this.nsResolver,
                                9, null);

                            &#x2F;&#x2F; Check if result for query was obtained
                            if (msgTypeNodeResult != null) {

                                &#x2F;&#x2F; Check SEPAmail root node was obtained
                                if (msgTypeNodeResult.singleNodeValue != null) {
                                    return true;
                                }
                            }
                        }
                    }

                } catch (e) {
                    throw e;
                }
            }
        }

        return false;
    },

    &#x2F;**
     * Get the URI associated with a given prefix
     *
     * @method nsResolver
     * @param {String} prefix Namespace prefix
     * @return {String} URI associated with the given prefix
     *&#x2F;
    nsResolver : function(prefix) {

        &#x2F;&#x2F; Namespace prefix mapping object
        var ns = {
            &#x27;p09&#x27; : &#x27;urn:iso:std:iso:20022:tech:xsd:pain.009.001.01&#x27;,
            &#x27;p012&#x27; : &#x27;urn:iso:std:iso:20022:tech:xsd:pain.012.001.01&#x27;,
            &#x27;pain013&#x27; : &#x27;urn:iso:std:iso:20022:tech:xsd:pain.013.001.01&#x27;,
            &#x27;pain014&#x27; : &#x27;urn:iso:std:iso:20022:tech:xsd:pain.014.001.01&#x27;,
            &#x27;sem&#x27; : &#x27;http:&#x2F;&#x2F;www.sepamail.eu&#x2F;xsd&#x2F;bleedingEdge&#x27;,
            &#x27;xsi&#x27; : &#x27;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&#x27;
        };

        &#x2F;&#x2F; Get the namespace URI for the given prefix
        return ns[prefix] || null;
    },

    &#x2F;**
     * openComposeWindow function opens a compose window based on the parametered content
     *
     * @method openComposeWindow
     * @param {String} aContent
     * @param {Object} account Account Object
     * @param {Object} aHeader Header object to reply to or null for a new mail
     * @param {String} defaultSubject The default subject of a SEPAmail message
     *&#x2F;
    openComposeWindow : function(aContent, account, aHeader, defaultSubject) {

        try {

            &#x2F;&#x2F; Compose service fields instance
            var composeFields = Components.classes[&quot;@mozilla.org&#x2F;messengercompose&#x2F;composefields;1&quot;]
                                          .createInstance(Components.interfaces.nsIMsgCompFields);

            composeFields.body = aContent;
            composeFields.characterSet = &quot;UTF-8&quot;;
            composeFields.from = account.defaultIdentity.email;

            if (null != aHeader) {
                composeFields.messageId = aHeader.messageId;
                &#x2F;&#x2F; REM MSO why not mime2DecodedSubject ?
                if (aHeader.subject == defaultSubject) {
                    composeFields.subject = &#x27;&#x27;;
                } else {
                    composeFields.subject = aHeader.subject;
                }
                &#x2F;&#x2F; REM MSO explain mime2DecodedAuthor
                composeFields.to = aHeader.mime2DecodedAuthor;
            }

            &#x2F;&#x2F; Message compose parameters instance
            var msgComposeParams = Components.classes[&quot;@mozilla.org&#x2F;messengercompose&#x2F;composeparams;1&quot;]
                                             .createInstance(Components.interfaces.nsIMsgComposeParams);

            &#x2F;&#x2F; Define the message composition parameters
            msgComposeParams.composeFields = composeFields;
            msgComposeParams.identity = account.defaultIdentity;
            msgComposeParams.format = Components.interfaces.nsIMsgCompFormat.PlainText
            msgComposeParams.type = Components.interfaces.nsIMsgCompType.New;

            &#x2F;&#x2F; Message compose service
            var msgComposeService = Components.classes[&quot;@mozilla.org&#x2F;messengercompose;1&quot;]
                                              .getService(Components.interfaces.nsIMsgComposeService);

            &#x2F;&#x2F; Remove vCards and signatures from missive email
            this.removeEmailExtras(msgComposeService);

            &#x2F;&#x2F; Open the message composition window
            msgComposeService.OpenComposeWindowWithParams(null, msgComposeParams);

        } catch (ex) {
            throw ex;
        }
    },

    &#x2F;**
     * populateQXBAN function populates the XML Object with sender and receiver QXBAN
     *
     * @method populateQXBAN
     * @param {Object} aMsgCompose Message compose object
     * @param {Object} aDocument Document containing the compose message body
     * @param {Object} xmlContent XML DOM containing SEPAmail message
     *&#x2F;
    populateQXBAN : function(aMsgCompose, aDocument, xmlContent) {

        try {

            var accountMenuItems = aDocument.getElementById(&quot;msgIdentityPopup&quot;).
                getElementsByTagNameNS(&quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;, &quot;menuitem&quot;);

            var accountKey;

            for (var i = 0; i &lt; accountMenuItems.length; i++) {

                if (accountMenuItems[i].selected) {
                    accountKey = accountMenuItems[i].getAttribute(&quot;accountkey&quot;);
                    break;
                }
            }

            if (accountKey != undefined) {

                var myQXBAN = this.getQxbanByEmailAddressAccount(accountKey);
                var receiverAccount = this.getMailAccountByAlias(aMsgCompose.compFields.to);
                var receiverQXBAN = receiverAccount == null ?
                    this.getReceiverQxbanByEmailAddress(aMsgCompose.compFields.to) :
                    this.getQxbanByEmailAddressAccount(receiverAccount.key);

                &#x2F;&#x2F; Check if the SEPAmail account of the sender was obtained
                if (myQXBAN == null) {
                    this.showAlert(&#x27;SMETH&#x27;, this.messageBundle.getLocalisedMessage(&#x27;qxban.sender.undefined&#x27;));
                    return false;
                }

                if (receiverQXBAN == null) {
                    this.showAlert(&#x27;SMETH&#x27;, this.messageBundle.getLocalisedMessage(&#x27;qxban.receiver.undefined&#x27;));
                    return false;
                }

                &#x2F;&#x2F; Set the sender IBAN value
                this.setNodeValue(xmlContent, &quot;&#x2F;sem:Missive&#x2F;sem:sepamail_missive_001&#x2F;sem:MsvHdr&#x2F;sem:Snd&#x2F;sem:IBAN&quot;,
                    myQXBAN.qxban);

                &#x2F;&#x2F; Set the receiver IBAN value
                this.setNodeValue(xmlContent, &quot;&#x2F;sem:Missive&#x2F;sem:sepamail_missive_001&#x2F;sem:MsvHdr&#x2F;sem:Rcv&#x2F;sem:IBAN&quot;,
                    receiverQXBAN.qxban);

                return true;

            } else {
                throw new Error(&quot;No account was detected&quot;);
            }

        } catch(ex) {
            throw ex;
        }
    },

    &#x2F;**
     * Remove extra&#x27;s such as email signature or vCards from message compose service
     *
     * @method removeEmailExtras
     * @param {Object} msgComposeService Message compose service
     *&#x2F;
    removeEmailExtras : function(msgComposeService) {

        &#x2F;&#x2F; Remove signature and VCard from default identity
        if (msgComposeService.defaultIdentity != undefined) {
            msgComposeService.defaultIdentity.attachSignature = false;
            msgComposeService.defaultIdentity.attachVCard = false;
        }

        &#x2F;&#x2F; Remove signature and VCard from identity
        if (msgComposeService.identity != undefined) {
            msgComposeService.identity.attachSignature = false;
            msgComposeService.identity.attachVCard = false;
        }
    },

    &#x2F;**
     * Save a file to local storage
     *
     * @method saveEmlToFile
     * @param {String} filename Name of the file
     * @param {String} content File content
     *&#x2F;
    saveEmlToFile : function(filename, content) {

        &#x2F;&#x2F; Obtain the location at which the file needs to be saved
        const nsIFilePicker = Components.interfaces.nsIFilePicker;

        &#x2F;&#x2F; File picker instance
        var fp = Components.classes[&quot;@mozilla.org&#x2F;filepicker;1&quot;]
                           .createInstance(nsIFilePicker);
        fp.init(this._window, &quot;Save file &quot; + filename, nsIFilePicker.modeSave);
        fp.defaultString = filename;

        &#x2F;&#x2F; Show the file picker
        var rv = fp.show();

        &#x2F;&#x2F; Check if user has chosen an attachment file location
        if (rv == nsIFilePicker.returnOK || rv == nsIFilePicker.returnReplace) {

            try {

                &#x2F;&#x2F; File to which content needs to be written
                var file = fp.file;

                &#x2F;&#x2F; Stream for writing to text file
                var ostream = FileUtils.openSafeFileOutputStream(file)

                &#x2F;&#x2F; UTF-8 convertor
                var converter = Components.classes[&quot;@mozilla.org&#x2F;intl&#x2F;scriptableunicodeconverter&quot;]
                                          .createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
                converter.charset = &quot;UTF-8&quot;;

                &#x2F;&#x2F; Get the UTF-8 version of the XML file content
                var istream = converter.convertToInputStream(content);

                &#x2F;&#x2F; Write content to file
                NetUtil.asyncCopy(istream, ostream);

            } catch (e) {
                throw e;
            }
        }
    },

    &#x2F;**
     * Save a file to local storage
     *
     * @method saveToFile
     * @param {String} filename Name of the file
     * @param {String} content File content
     *&#x2F;
    saveToFile : function(filename, content) {

        &#x2F;&#x2F; Obtain the location at which the file needs to be saved
        const nsIFilePicker = Components.interfaces.nsIFilePicker;

        &#x2F;&#x2F; File picker instance
        var fp = Components.classes[&quot;@mozilla.org&#x2F;filepicker;1&quot;]
                           .createInstance(nsIFilePicker);
        fp.init(this._window, &quot;Save file &quot; + filename, nsIFilePicker.modeSave);
        fp.defaultString = filename;

        &#x2F;&#x2F; Show the file picker
        var rv = fp.show();

        &#x2F;&#x2F; Check if user has chosen an attachment file location
        if (rv == nsIFilePicker.returnOK || rv == nsIFilePicker.returnReplace) {

            try {

                &#x2F;&#x2F; File to which content needs to be written
                var file = fp.file;

                &#x2F;&#x2F; Decode the content
                var decodedContent = this._window.atob(content);

                &#x2F;&#x2F; Stream for writing binary file
                var stream = Components.classes[&quot;@mozilla.org&#x2F;network&#x2F;safe-file-output-stream;1&quot;]
                                       .createInstance(Components.interfaces.nsIFileOutputStream);
                stream.init(file, 0x04 | 0x08 | 0x20, 0600, 0);
                stream.write(decodedContent, decodedContent.length);

                &#x2F;&#x2F; Close the stream
                if (stream instanceof Components.interfaces.nsISafeOutputStream) {
                    stream.finish();
                } else {
                    stream.close();
                }

            } catch (e) {
                throw e;
            }
        }
    },

    &#x2F;**
     * Save a file to local storage
     *
     * @method saveToFile
     * @param {String} filename Name of the file
     * @param {String} content File content
     *&#x2F;
    saveXmlToFile : function(filename, content) {

        &#x2F;&#x2F; Obtain the location at which the file needs to be saved
        const nsIFilePicker = Components.interfaces.nsIFilePicker;

        &#x2F;&#x2F; File picker instance
        var fp = Components.classes[&quot;@mozilla.org&#x2F;filepicker;1&quot;]
                           .createInstance(nsIFilePicker);
        fp.init(this._window, &quot;Save file &quot; + filename, nsIFilePicker.modeSave);
        fp.defaultString = filename;

        &#x2F;&#x2F; Show the file picker
        var rv = fp.show();

        &#x2F;&#x2F; Check if user has chosen an attachment file location
        if (rv == nsIFilePicker.returnOK || rv == nsIFilePicker.returnReplace) {

            try {

                &#x2F;&#x2F; File to which content needs to be written
                var file = fp.file;

                &#x2F;&#x2F; Stream for writing to text file
                var ostream = FileUtils.openSafeFileOutputStream(file)

                &#x2F;&#x2F; UTF-8 convertor
                var converter = Components.classes[&quot;@mozilla.org&#x2F;intl&#x2F;scriptableunicodeconverter&quot;]
                                          .createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
                converter.charset = &quot;UTF-8&quot;;

                &#x2F;&#x2F; Get the UTF-8 version of the XML file content
                var istream = converter.convertToInputStream(&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&#x27; + content);

                &#x2F;&#x2F; Write content to file
                NetUtil.asyncCopy(istream, ostream);

            } catch (e) {
                throw e;
            }
        }
    },

    &#x2F;**
     * setMessageExpiry sets the validy of the missive message
     *
     * @method setMessageExpiry
     * @param {Object} xmlContent XML DOM containing the missive message
     *&#x2F;
    setMessageExpiry : function(xmlContent) {

        &#x2F;&#x2F; Message expiry container
        var expiryContainerNode = xmlContent.evaluate(&quot;&#x2F;sem:Missive&#x2F;sem:sepamail_missive_001&#x2F;sem:MsvBdy&#x2F;sem:sepamail_message_001&#x2F;sem:MsgHdr&quot;,
            xmlContent, this.nsResolver, 9, null);

        &#x2F;&#x2F; Check if a message expiry tag exists within the current message
        var msgExpiryNode = xmlContent.getElementsByTagName(&quot;sem:MsgExpiry&quot;);

        try {

            &#x2F;&#x2F; Remove the message expiry node from the container
            while (msgExpiryNode[0] != null) {
                expiryContainerNode.singleNodeValue.removeChild(msgExpiryNode[0]);
            }

            &#x2F;&#x2F; Check if we need to append message expiry to the message being sent
            if (this._smethPreferences.getBoolPref(&#x27;hasExpiry&#x27;)) {

                &#x2F;&#x2F; Get the message expiry duration object
                var expiryDuration = this.getMessageExpiryDuration();

                &#x2F;&#x2F; Initialise expiry date to now
                var expiryDate = new this._window.Date();

                &#x2F;&#x2F; Calculate the message expiry date and time
                expiryDate.setFullYear(expiryDate.getFullYear() + expiryDuration.years,
                    expiryDate.getMonth() + expiryDuration.months, expiryDate.getDate() + expiryDuration.days);

                &#x2F;&#x2F; New element for MsgExpiry node
                var expiryNode = xmlContent.createElement(&#x27;sem:MsgExpiry&#x27;);

                &#x2F;&#x2F; Set the &quot;MsgExpiry&quot; value
                expiryNode.textContent = this.formatDateForSEPAmail(expiryDate);

                &#x2F;&#x2F; Append the message expiry node to the message
                expiryContainerNode.singleNodeValue.appendChild(expiryNode);
            }

        } catch(ex) {
            this._smethMessageHandler.exception(ex);
        }
    },

    &#x2F;**
     * setMessageId sets the ID of a message by using the UUID generator of Thunderbird
     *
     * @method setMessageId
     * @param {Object} xmlContent XML DOM for missive content
     *&#x2F;
    setMessageId : function (xmlContent) {

        &#x2F;&#x2F; Set the &quot;MsgId&quot; value
        this.setNodeValue(xmlContent,
            &quot;&#x2F;sem:Missive&#x2F;sem:sepamail_missive_001&#x2F;sem:MsvBdy&#x2F;sem:sepamail_message_001&#x2F;sem:MsgHdr&#x2F;sem:MsgId&quot;,
            this.generateMessageId());
    },

    &#x2F;**
     * setMissiveId sets the ID of a missive by using the UUID generator of Thunderbird
     *
     * @method setMissiveId
     * @param {Object} xmlContent XML DOM for missive content
     *&#x2F;
    setMissiveId : function(xmlContent) {

        &#x2F;&#x2F; UUID generator instance
        var uuidGenerator = Components.classes[&quot;@mozilla.org&#x2F;uuid-generator;1&quot;]
                                      .getService(Components.interfaces.nsIUUIDGenerator);

        &#x2F;&#x2F; Set the &quot;MsvId&quot; value
        this.setNodeValue(xmlContent, &quot;&#x2F;sem:Missive&#x2F;sem:sepamail_missive_001&#x2F;sem:MsvId&quot;,
            ((uuidGenerator.generateUUID().toString().replace(&#x2F;-&#x2F;g, &quot;&quot;)).substring(1, 17)).toUpperCase());
    },

    &#x2F;**
     * Set the text value of a node in a given xml doc
     *
     * @method setNodeAttribute
     * @param {XML} anXMLDoc RequestXML Document
     * @param {String} anXpath Node Xpath
     * @param {String} anAttribute Node attribute
     * @param {String} anAttributeValue Node attribute value
     *&#x2F;
    setNodeAttribute : function(anXMLDoc, anXpath, anAttribute, anAttributeValue) {

        &#x2F;&#x2F; Get the specific node
        var node = anXMLDoc.evaluate(anXpath, anXMLDoc, this.nsResolver, 9, null);

        node.singleNodeValue.setAttribute(anAttribute, anAttributeValue);
    },

    &#x2F;**
     * Set the text value of a node in a given xml doc
     *
     * @method setNodeValue
     * @param {XML} anXMLDoc RequestXML Document
     * @param {String} anXpath  Node Xpath
     * @param {String} aValue   Node Value
     *&#x2F;
    setNodeValue : function(anXMLDoc, anXpath, aValue) {

        &#x2F;&#x2F; Get the specific node
        var node = anXMLDoc.evaluate(anXpath, anXMLDoc, this.nsResolver, 9, null);

        node.singleNodeValue.textContent = aValue;
    },

    &#x2F;**
     * setSendDateTime sets the date and time at which a SEPAmail message was sent
     *
     * @method setSendDateTime
     * @param {Object} xmlContent XML DOM containing the missive message
     *&#x2F;
    setSendDateTime : function(xmlContent) {

        &#x2F;&#x2F; Set the &quot;SndDtTm&quot; value
        this.setNodeValue(xmlContent, &quot;&#x2F;sem:Missive&#x2F;sem:sepamail_missive_001&#x2F;sem:MsvHdr&#x2F;sem:SndDtTm&quot;,
            this.formatDateForSEPAmail(new this._window.Date()));
    },

    &#x2F;**
     * Display an alert with the given title and message
     *
     * @method showAlert
     * @param {String} title The title of the alert
     * @param {String} message The message of the alert
     *&#x2F;
    showAlert : function(title, message) {

        &#x2F;&#x2F; Prompt service instance
        var promptService = Components.classes[&quot;@mozilla.org&#x2F;embedcomp&#x2F;prompt-service;1&quot;]
                                      .getService(Components.interfaces.nsIPromptService);

        &#x2F;&#x2F; Display alert with given title and message
        promptService.alert(null, title, message);
    },

    &#x2F;**
     * transformXMLDocument function transforms a XML document using a XSL file URL
     *
     * @method transformXMLDocument
     * @param {XML} anXML XML doucmnet to be transformed
     * @param {String} anXSLUrl XSL Style sheet url which will be use for transformation
     * @return {XML} Transformed XML document
     * @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;XPCOM_Interface_Reference&#x2F;nsIXSLTProcessor
     * REM MSO 20121210 try not to use xmlHttpRequest, vulnerability (TODO)
     *&#x2F;
    transformXMLDocument : function (anXML, anXSLUrl) {

        try
        {
            &#x2F;&#x2F; Declare the XMLHttpRequest to load the XSL
            var xmlHttpRequest = Components.classes[&quot;@mozilla.org&#x2F;xmlextras&#x2F;xmlhttprequest;1&quot;]
                                 .createInstance();

            &#x2F;&#x2F; Send request for the XSL document
            xmlHttpRequest.open(&#x27;GET&#x27;, anXSLUrl, false);
            xmlHttpRequest.send();

            &#x2F;&#x2F; Get the XSL document object
            var xslDocument = xmlHttpRequest.responseXML;

            &#x2F;&#x2F; Instantiate the XSLT Processor
            &#x2F;&#x2F; @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Using_the_Mozilla_JavaScript_interface_to_XSL_Transformations#Using_XSLTProcessor_from_XPCOM_components
            var xsltProcessor= Components.classes[&quot;@mozilla.org&#x2F;document-transformer;1?type=xslt&quot;]
                               .createInstance(Components.interfaces.nsIXSLTProcessor);

            &#x2F;&#x2F; Import the XSL document object in the XSLT processor
            xsltProcessor.importStylesheet(xslDocument);

            &#x2F;&#x2F; Declare an empty XML document that will own the fragment
            var resultDocumentOwner = this._window.document.implementation.createDocument(&quot;&quot;, &quot;&quot;, null);

            &#x2F;&#x2F; Get the resulting transformation fragment
            var resultFragment = xsltProcessor.transformToFragment(anXML,resultDocumentOwner);

            &#x2F;&#x2F; Append the result fragment to its fragment owner
            resultDocumentOwner.appendChild(resultFragment);

            return resultDocumentOwner;
        }
        catch(ex)
        {
            throw ex;
        }
    },

    &#x2F;**
     * Set the translated text for the given list of controls
     *
     * @method translateSmethControlElements
     * @param {Array} smethControls List of SMETH UI controls
     * @param {Object} smethTranslationObject Contains the tranalations text that will be used to translate
     *&#x2F;
    translateSmethControlElements : function(smethControls, smethTranslationObject) {

        &#x2F;&#x2F; Loop the array of controls and set the appropriate control labels
        for (var i = 0; i &lt; smethControls.length; i++) {

            &#x2F;&#x2F; Get a translated text for the current control
            var localeText = smethTranslationObject[smethControls[i].id];

            &#x2F;&#x2F; Get a translated tooltip text for the current control
            var localeTextTooltip = smethTranslationObject[smethControls[i].id + &quot;Tooltip&quot;];

            &#x2F;&#x2F; Check if we have a translation the current control
            if (localeText != null) {

                &#x2F;&#x2F; Set the appropriate label of the control
                switch (smethControls[i].tagName) {

                    case &#x27;label&#x27;:
                        if (isNaN(smethControls[i].getAttribute(&#x27;value&#x27;))) {
                            smethControls[i].setAttribute(&#x27;value&#x27;, localeText);
                        }
                        break;

                    case &#x27;button&#x27;:
                        smethControls[i].setAttribute(&#x27;label&#x27;, localeText);
                        break;

                    case &#x27;menuitem&#x27;:
                        smethControls[i].setAttribute(&#x27;label&#x27;, localeText);
                        break;

                    case &#x27;toolbarbutton&#x27;:
                        smethControls[i].setAttribute(&#x27;label&#x27;, localeText);
                        break;

                }
            } else {}

            &#x2F;&#x2F; Check if we have a translation the current control
            if (localeTextTooltip != null) {

                &#x2F;&#x2F; Set the appropriate label of the control
                switch (smethControls[i].tagName) {

                    case &#x27;label&#x27;:
                        smethControls[i].setAttribute(&#x27;tooltiptext&#x27;, localeTextTooltip);
                        break;

                    case &#x27;button&#x27;:
                        smethControls[i].setAttribute(&#x27;tooltiptext&#x27;, localeTextTooltip);
                        break;

                    case &#x27;menuitem&#x27;:
                        smethControls[i].setAttribute(&#x27;tooltiptext&#x27;, localeTextTooltip);
                        break;

                    case &#x27;toolbarbutton&#x27;:
                        smethControls[i].setAttribute(&#x27;tooltiptext&#x27;, localeTextTooltip);
                        break;

                    case &#x27;hbox&#x27;:
                        smethControls[i].setAttribute(&#x27;tooltiptext&#x27;, localeTextTooltip);
                        break;

                }
            } else {}
        }
    },

    &#x2F;**
     * Set SMETH UI labels as per user locale
     *
     * @method translateSEPAmailDocument
     * @param {XML} smethXulDom XUL fragment which contains the SMETH UI
     * @param {Object} smethTranslationObject Contains the translations text that will be used to translate
     * @return {XML} SMETH UI as XUL fragment with translated labels
     *&#x2F;
    translateSEPAmailDocument : function (smethXulDom, smethTranslationObject) {

        try {

            &#x2F;&#x2F; Set the text for the list of labels
            this.translateSmethControlElements(smethXulDom.getElementsByTagNameNS(
                &quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;, &quot;label&quot;), smethTranslationObject);

            &#x2F;&#x2F; Set the text for the buttons from the SMETH UI
            this.translateSmethControlElements(smethXulDom.getElementsByTagNameNS(
                &quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;, &quot;button&quot;), smethTranslationObject);

            &#x2F;&#x2F; Set the text for the menuitem from the SMETH UI
            this.translateSmethControlElements(smethXulDom.getElementsByTagNameNS(
                &quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;, &quot;menuitem&quot;), smethTranslationObject);

            &#x2F;&#x2F; Set the text for the toolbarbutton from the SMETH UI
            this.translateSmethControlElements(smethXulDom.getElementsByTagNameNS(
                &quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;, &quot;toolbarbutton&quot;), smethTranslationObject);

                &#x2F;&#x2F; Set the text for the hbox from the SMETH UI
            this.translateSmethControlElements(smethXulDom.getElementsByTagNameNS(
                &quot;http:&#x2F;&#x2F;www.mozilla.org&#x2F;keymaster&#x2F;gatekeeper&#x2F;there.is.only.xul&quot;, &quot;hbox&quot;), smethTranslationObject);

            return smethXulDom;

        } catch (e) {
            throw e;
        }
    }
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
