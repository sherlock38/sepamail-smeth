<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE bindings [
    <!ENTITY % smethOptionsDTD SYSTEM "chrome://smeth/locale/SMETHOption.dtd" > %smethOptionsDTD;
]>

<bindings id="smethBindings"
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:nc="http://home.netscape.com/NC-rdf#"
    xmlns:xbl="http://www.mozilla.org/xbl">

    <binding id="missiveattachmentlist-base" extends="chrome://global/content/bindings/listbox.xml#listbox-base">
        <implementation>
            <constructor><![CDATA[
                let children = Array.slice(this._childNodes);

                children.filter(function(aChild) aChild.getAttribute("selected") == "true")
                    .forEach(this.selectedItems.push, this.selectedItems);

                children.filter(function(aChild) !aChild.hasAttribute("context"))
                    .forEach(function(aChild) aChild.setAttribute("context", this.getAttribute("itemcontext")), this);

                this.sizes = {small: 16, large: 32, tile: 32};
                this.messenger = Components.classes["@mozilla.org/messenger;1"]
                    .createInstance(Components.interfaces.nsIMessenger);

            ]]></constructor>

            <!-- ///////////////// public members ///////////////// -->

            <property name="view">
                <getter><![CDATA[
                    return this.getAttribute("view");
                ]]></getter>
                <setter><![CDATA[
                    this.setAttribute("view", val);
                    this._setImageSize();
                    return val;
                ]]></setter>
            </property>

            <property name="orient">
                <getter><![CDATA[
                    return this.getAttribute("orient");
                ]]></getter>
                <setter><![CDATA[
                    // The current item can get messed up when changing orientation.
                    let curr = this.currentItem;
                    this.currentItem = null;

                    this.setAttribute("orient", val);
                    this.currentItem = curr;
                    return val;
                ]]></setter>
            </property>

            <property name="itemCount" readonly="true" onget="return this._childNodes.length;"/>

            <method name="getIndexOfItem">
                <parameter name="item"/>
                <body><![CDATA[
                    for (let i = 0; i < this._childNodes.length; i++) {
                        if (this._childNodes[i] === item)
                            return i;
                    }
                    return -1;
                ]]></body>
            </method>
            <method name="getItemAtIndex">
                <parameter name="index"/>
                <body><![CDATA[
                    if (index >= 0 && index < this._childNodes.length)
                        return this._childNodes[index];
                    return null;
                ]]></body>
            </method>
            <method name="getRowCount">
                <body><![CDATA[
                    return this._childNodes.length;
                ]]></body>
            </method>
            <method name="getNumberOfVisibleRows">
                <body><![CDATA[
                    let itemsPerRow = this._itemsPerRow();
                    return itemsPerRow * this._itemsPerCol(itemsPerRow);
                ]]></body>
            </method>
            <method name="getIndexOfFirstVisibleRow">
                <body><![CDATA[
                    if (this._childNodes.length == 0)
                        return -1;

                    // First try to estimate which row is visible, assuming they're all the same height.
                    let box = this.scrollbox;
                    let estimatedRow = Math.floor(box.scrollTop / this._childNodes[0].boxObject.height);
                    let estimatedIndex = estimatedRow * this._itemsPerRow();
                    let offset = this._childNodes[estimatedIndex].boxObject.screenY - box.boxObject.screenY;

                    if (offset > 0) {

                        // We went too far! Go back until we find an item totally off-screen, then return the one after
                        // that.
                        for (let i = estimatedIndex - 1; i >= 0; i--) {
                            let childBoxObj = this._childNodes[i].boxObject;
                            if (childBoxObj.screenY + childBoxObj.height <= box.boxObject.screenY)
                                return i+1;
                        }

                        // If we get here, we must have gone back to the beginning of the list, so just return 0.
                        return 0;

                    } else {

                        // We didn't go far enough! Keep going until we find an item at least partially on-screen.
                        for (let i = estimatedIndex; i < this._childNodes.length; i++) {
                            let childBoxObj = this._childNodes[i].boxObject;
                            if (childBoxObj.screenY + childBoxObj.height > box.boxObject.screenY > 0)
                                return i;
                        }

                        // If we get here, something is very wrong.
                        Components.utils.reportError("Couldn't get index of first visible row for attachmentlist!\n");
                        return -1;
                    }
                ]]></body>
            </method>
            <method name="ensureIndexIsVisible">
                <parameter name="index"/>
                <body><![CDATA[
                    this.ensureElementIsVisible(this.getItemAtIndex(index));
                ]]></body>
            </method>
            <method name="ensureElementIsVisible">
                <parameter name="item"/>
                <body><![CDATA[
                    let box = this.scrollbox;

                    // Are we too far down?
                    if (item.boxObject.screenY < box.boxObject.screenY)
                        box.scrollTop = item.boxObject.y - box.boxObject.y;

                    // ... or not far enough?
                    else if (item.boxObject.screenY + item.boxObject.height >
                        box.boxObject.screenY + box.boxObject.height)
                        box.scrollTop = item.boxObject.y + item.boxObject.height - box.boxObject.y -
                            box.boxObject.height;

                ]]></body>
            </method>
            <method name="scrollToIndex">
                <parameter name="index"/>
                <body><![CDATA[
                    let box = this.scrollbox;
                    let item = this.getItemAtIndex(index);
                    if (!item)
                        return;
                    box.scrollTop = item.boxObject.y - box.boxObject.y;
                ]]></body>
            </method>
            <method name="appendItem">
                <parameter name="attachment"/>
                <parameter name="name"/>
                <body><![CDATA[
                    // -1 appends due to the way getItemAtIndex is implemented.
                    return this.insertItemAt(-1, attachment, name);
                ]]></body>
            </method>
            <method name="insertItemAt">
                <parameter name="index"/>
                <parameter name="attachment"/>
                <parameter name="name"/>
                <body><![CDATA[
                    const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
                    let item = this.ownerDocument.createElementNS(XULNS, "missiveattachmentitem");
                    item.setAttribute("name", name || attachment.name);

                    let size;
                    if (attachment.size != null && attachment.size != -1)
                        size = this.messenger.formatFileSize(attachment.size);
                    else // Use a zero-width space so the size label has the right height.
                        size = "\u200b";
                    item.setAttribute("size", size);

                    // Pick out some nice icons (small and large) for the attachment
                    if (attachment.contentType == "text/x-moz-deleted") {
                        let base = "chrome://messenger/skin/icons/";
                        item.setAttribute("image16", base+"attachment-deleted.png");
                        item.setAttribute("image32", base+"attachment-deleted-large.png");
                    } else {
                        item.setAttribute("image16", "moz-icon://" + attachment.name + "?size=16&amp;contentType=" +
                            attachment.contentType);
                        item.setAttribute("image32", "moz-icon://" + attachment.name + "?size=32&amp;contentType=" +
                            attachment.contentType);
                    }

                    item.setAttribute("imagesize", this.sizes[this.getAttribute("view")] || 16);
                    item.setAttribute("context", this.getAttribute("itemcontext"));
                    item.attachment = attachment;

                    this.insertBefore(item, this.getItemAtIndex(index));
                    return item;
                ]]></body>
            </method>

            <method name="scrollOnePage">
                <parameter name="direction"/>  <!-- Must be -1 or 1 -->
                <body><![CDATA[
                    let pageOffset = this.getNumberOfVisibleRows() * direction;
                    let firstVisibleIndex = this.getIndexOfFirstVisibleRow();

                    // skip over invisible elements - the user won't care about them
                    for (let i = 0; i != pageOffset; i += direction) {
                        let item = this.getItemAtIndex(firstVisibleIndex + i);
                        if (item && !this._canUserSelect(item))
                            pageOffset += direction;
                    }

                    let newTop = firstVisibleIndex + pageOffset;
                    if (direction == 1) {
                        let maxTop = this.getRowCount() - this.getNumberOfVisibleRows();
                        for (let i = this.getRowCount(); i >= 0 && i > maxTop; i--) {
                            let item = this.getItemAtIndex(i);
                            if (item && !this._canUserSelect(item))
                                maxTop--;
                        }
                        if (newTop >= maxTop)
                            newTop = maxTop;
                    }
                    if (newTop < 0)
                        newTop = 0;
                    this.scrollToIndex(newTop);
                    return pageOffset;
                ]]></body>
            </method>

            <!-- Get the preferred height (the height that would allow us to fit everything without scrollbars) of the
                 attachmentlist's boxObject. -->
            <property name="preferredHeight" readonly="true"
                onget="return this.scrollbox.scrollHeight - this.scrollbox.clientHeight + this.boxObject.height;"/>

            <!-- Find the attachmentitem node for the specified nsIMsgAttachment. -->
            <method name="findItemForAttachment">
                <parameter name="aAttachment"/>
                <body><![CDATA[
                    for (let i = 0; i < this.itemCount; i++) {
                        let item = this.getItemAtIndex(i);
                        if (item.attachment == aAttachment)
                            return item;
                    }
                    return null;
                ]]></body>
            </method>

            <!-- ///////////////// private members ///////////////// -->

            <field name="_childNodes" readonly="true">this.getElementsByTagName("missiveattachmentitem")</field>
            <property name="scrollbox" readonly="true"
                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'scrollbox');"/>

            <method name="_fireOnSelect">
                <body><![CDATA[
                    if (!this._suppressOnSelect && !this.suppressOnSelect) {
                        let evt = document.createEvent("Events");
                        evt.initEvent("select", false, true);
                        this.dispatchEvent(evt);
                    }
                ]]></body>
            </method>

            <method name="_itemsPerRow">
                <body><![CDATA[
                    // For 0 or 1 children, we can assume that they all fit in one row.
                    if (this._childNodes.length < 2)
                        return this._childNodes.length;

                    let itemWidth = this._childNodes[1].boxObject.x - this._childNodes[0].boxObject.x;

                    if (itemWidth == 0) // Each item takes up a full row
                      return 1;
                    else
                      return Math.floor(this.scrollbox.clientWidth / itemWidth);
                ]]></body>
            </method>

            <method name="_itemsPerCol">
                <parameter name="aItemsPerRow"/>
                <body><![CDATA[
                    let itemsPerRow = aItemsPerRow || this._itemsPerRow();

                    if (this._childNodes.length == 0)
                        return 0;
                    else if (this._childNodes.length <= itemsPerRow)
                        return 1;

                    let itemHeight = this._childNodes[itemsPerRow].boxObject.y - this._childNodes[0].boxObject.y;

                    return Math.floor(this.scrollbox.clientHeight / itemHeight);
                ]]></body>
            </method>

            <method name="_setImageSize">
                <body><![CDATA[
                    let size = this.sizes[this.view] || 16;

                    for (let i = 0; i < this._childNodes.length; i++)
                        this._childNodes[i].imageSize = size;
                ]]></body>
            </method>
        </implementation>

        <handlers>
            <!-- The spacebar should work just like the arrow keys, except that the focused element doesn't change, so
                 use moveByOffset here. -->
            <handler event="keypress" key=" " modifiers="control shift any" phase="target" preventdefault="true"
                 action="this.moveByOffset(0, !event.ctrlKey, event.shiftKey);"/>
            <handler event="keypress" keycode="VK_RETURN"><![CDATA[
                if (this.currentItem) {
                    this.addItemToSelection(this.currentItem);
                    let evt = document.createEvent("XULCommandEvent");
                    evt.initCommandEvent("command", true, true, window, 0, event.ctrlKey, event.altKey, event.shiftKey,
                        event.metaKey, null);
                    this.currentItem.dispatchEvent(evt);
                }
            ]]></handler>
            <handler event="click" button="0" phase="target"><![CDATA[
                if (this.selType != "multiple" || (!event.ctrlKey && !event.shiftKey && !event.metaKey))
                    this.clearSelection();
            ]]></handler>
            <!-- make sure we keep the focus... -->
            <handler event="mousedown" button="0"
                 action="if (document.commandDispatcher.focusedElement != this) this.focus();"/>
        </handlers>
    </binding>

    <binding id="missiveattachmentlist" extends="chrome://Smeth/content/smethWidgets.xml#missiveattachmentlist-base">
        <content>
            <xul:scrollbox flex="1" anonid="scrollbox" style="overflow: auto;">
                <xul:hbox flex="1" class="attachmentlist-wrapper">
                    <children includes="missiveattachmentitem"/>
                </xul:hbox>
            </xul:scrollbox>
        </content>
        <implementation>
            <method name="setOptimumWidth">
                <body><![CDATA[
                    if (this._childNodes.length == 0)
                        return;

                    let width = 0;
                    let border = this._childNodes[0].boxObject.width - this._childNodes[0].clientWidth;

                    for (let child of this._childNodes)
                        width = Math.max(width, child.scrollWidth);

                    for (let child of this._childNodes)
                        child.width = width + border;

                ]]></body>
            </method>
        </implementation>
        <handlers>
            <handler event="keypress" keycode="VK_LEFT" modifiers="control shift any"
                 action="this.moveByOffset(-1, !event.ctrlKey, event.shiftKey);" phase="target" preventdefault="true"/>
            <handler event="keypress" keycode="VK_RIGHT" modifiers="control shift any"
                 action="this.moveByOffset(1, !event.ctrlKey, event.shiftKey);" phase="target" preventdefault="true"/>
            <handler event="keypress" keycode="VK_UP" modifiers="control shift any"
                 action="this.moveByOffset(-this._itemsPerRow(), !event.ctrlKey, event.shiftKey);" phase="target"
                 preventdefault="true"/>
            <handler event="keypress" keycode="VK_DOWN" modifiers="control shift any"
                 action="this.moveByOffset(this._itemsPerRow(), !event.ctrlKey, event.shiftKey);" phase="target"
                 preventdefault="true"/>
        </handlers>
    </binding>

    <binding id="missiveattachmentitem" extends="chrome://global/content/bindings/listbox.xml#listitem">
        <implementation>
            <constructor><![CDATA[
                this._updateImage();
            ]]></constructor>

            <property name="imageSize">
                <getter><![CDATA[
                    return this.getAttribute("imagesize");
                ]]></getter>
                <setter><![CDATA[
                    this.setAttribute("imagesize", val);
                    this._updateImage();
                    return val;
                ]]></setter>
            </property>

            <property name="image">
                <getter><![CDATA[
                    return this.getAttribute("image");
                ]]></getter>
                <setter><![CDATA[
                    if (val)
                        this.setAttribute("image", val);
                    else
                        this.removeAttribute("image");
                    this._updateImage();
                    return val;
                ]]></setter>
            </property>

            <property name="data">
                <getter><![CDATA[
                    if (this._dataNodes.length > 0) {
                        return this._dataNodes[0];
                    } else {
                        return null;
                    }
                ]]></getter>
            </property>

            <property name="size">
                <getter><![CDATA[
                    if (this.hasAttribute("size")) {
                        return this.getAttribute("size");
                    } else {
                        return 0;
                    }
                ]]></getter>
                <setter><![CDATA[
                    if (val) {
                        this.setAttribute("size", val);
                    } else {
                        this.removeAttribute("size");
                    }
                    this._updateSize();
                ]]></setter>
            </property>

            <method name="_updateImage">
                <body><![CDATA[
                    if (!this.hasAttribute("image")) {
                        let icon = document.getAnonymousElementByAttribute(this, "anonid", "icon");
                        let attr = "image" + this.imageSize;
                        if (this.hasAttribute(attr))
                            icon.setAttribute("src", this.getAttribute(attr));
                    }
                ]]></body>
            </method>

            <method name="_updateSize">
                <body><![CDATA[
                    let size = document.getAnonymousElementByAttribute(this, "anonid", "size");
                    if (this.hasAttribute("size")) {
                        var byteSize = this.getAttribute("size");
                        if (!isNaN(byteSize)) {
                            if (byteSize > 0) {
                                if (byteSize < 1024) {
                                    size.setAttribute("value", byteSize.toLocaleString() + " bytes");
                                } else if (byteSize < 1048576) {
                                    var formattedKbSize = byteSize / 1024.00;
                                    size.setAttribute("value", formattedKbSize.toFixed(2).toLocaleString() + " KB");
                                } else {
                                    var formattedMbSize = byteSize / 1048576.00;
                                    size.setAttribute("value", formattedMbSize.toFixed(2).toLocaleString() + " MB");
                                }
                            } else {
                                size.setAttribute("value", "0");
                            }
                        } else {
                            size.setAttribute("value", "");
                        }
                    } else {
                        size.setAttribute("value", "");
                    }
                ]]></body>
            </method>

            <field name="_dataNodes" readonly="true">this.getElementsByTagName("data")</field>
        </implementation>
        <!-- Below, we want the name label to flex but not be any bigger than necessary, so add a spacer with a huge
             flex value. -->
        <content>
            <xul:hbox class="attachmentcell-content" flex="1">
                <xul:hbox align="center">
                    <xul:image class="attachmentcell-icon" anonid="icon" xbl:inherits="src=image"/>
                </xul:hbox>
                <xul:hbox class="attachmentcell-text" flex="1">
                    <xul:hbox class="attachmentcell-nameselection" flex="1">
                        <xul:label class="attachmentcell-name" xbl:inherits="value=name" flex="1" crop="center"/>
                    </xul:hbox>
                    <xul:spacer flex="99999"/>
                    <xul:label class="attachmentcell-size" anonid="size" xbl:inherits="value=size"/>
                </xul:hbox>
            </xul:hbox>
            <children includes="data"/>
        </content>
        <handlers>
            <handler event="click" button="0" clickcount="2"><![CDATA[
                let evt = document.createEvent("XULCommandEvent");
                evt.initCommandEvent("command", true, true, window, 0, event.ctrlKey, event.altKey, event.shiftKey,
                    event.metaKey, null);
                this.dispatchEvent(evt);
            ]]></handler>
        </handlers>
    </binding>

    <binding id="acknowledgementsettings">
        <implementation>
            <constructor><![CDATA[
                if (this.hasAttribute('automatic')) {
                    let automatic = this.getAttribute('automatic');
                } else {
                    let automatic = document.getAnonymousElementByAttribute(this, "anonid", "automaticoptions").value;
                }
                if (this.hasAttribute('retClass')) {
                    document.getAnonymousElementByAttribute(this, "anonid", "classvalue").value = this.getAttribute('retClass');
                }
                if (this.hasAttribute('subject')) {
                    document.getAnonymousElementByAttribute(this, "anonid", "subjectvalue").value = this.getAttribute('subject');
                }
                if (this.hasAttribute('detail')) {
                    document.getAnonymousElementByAttribute(this, "anonid", "detailvalue").value = this.getAttribute('detail');
                }
            ]]></constructor>
            <property name="automatic">
                <getter><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", "automaticoptions").value;
                ]]></getter>
                <setter><![CDATA[
                    if (val) {
                        this.setAttribute('automatic', val);
                        document.getAnonymousElementByAttribute(this, "anonid", "automaticoptions").value = val;
                    }
                ]]></setter>
            </property>
            <property name="automaticSending" readonly="true">
                <getter><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", "automaticoptions").value == '1';
                ]]></getter>
            </property>
            <property name="class">
                <getter><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", "classvalue").value;
                ]]></getter>
                <setter><![CDATA[
                    if (val) {
                        document.getAnonymousElementByAttribute(this, "anonid", "classvalue").value = val;
                        this.setAttribute('retClass', val);
                    }
                ]]></setter>
            </property>
            <property name="defaultSettings" readonly="true">
                <getter><![CDATA[
                    return {
                        'status' : document.getAnonymousElementByAttribute(this, "anonid", "statusvalue").value,
                        'retClass' : document.getAnonymousElementByAttribute(this, "anonid", "classvalue").value,
                        'subject' : document.getAnonymousElementByAttribute(this, "anonid", "subjectvalue").value,
                        'detail' : document.getAnonymousElementByAttribute(this, "anonid", "detailvalue").value,
                        'description' : document.getAnonymousElementByAttribute(this, "anonid", "descriptionvalue").value
                    };
                ]]></getter>
            </property>
            <property name="description">
                <getter><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", "descriptionvalue").value;
                ]]></getter>
                <setter><![CDATA[
                    if (val) {
                        document.getAnonymousElementByAttribute(this, "anonid", "descriptionvalue").value = val;
                    }
                ]]></setter>
            </property>
            <property name="detail">
                <getter><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", "detailvalue").value;
                ]]></getter>
                <setter><![CDATA[
                    if (val) {
                        document.getAnonymousElementByAttribute(this, "anonid", "detailvalue").value = val;
                        this.setAttribute('detail', val);
                    }
                ]]></setter>
            </property>
            <property name="status">
                <getter><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", "statusvalue").value;
                ]]></getter>
                <setter><![CDATA[
                    if (val) {
                        document.getAnonymousElementByAttribute(this, "anonid", "statusvalue").value = val;
                        this.setAttribute('status', val);
                    }
                ]]></setter>
            </property>
            <property name="subject">
                <getter><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", "subjectvalue").value;
                ]]></getter>
                <setter><![CDATA[
                    if (val) {
                        document.getAnonymousElementByAttribute(this, "anonid", "subjectvalue").value = val;
                        this.setAttribute('subjectvalue', val);
                    }
                ]]></setter>
            </property>
            <method name="setAcknowledgementSettings">
                <parameter name="settings"/>
                <body><![CDATA[
                    if (settings != null) {
                        if (settings.status != undefined) {
                            document.getAnonymousElementByAttribute(this, "anonid", "statusvalue").value = settings.status;
                            this.setAttribute('status', settings.status);
                        }
                        if (settings.retClass != undefined) {
                            document.getAnonymousElementByAttribute(this, "anonid", "classvalue").value = settings.retClass;
                            this.setAttribute('retClass', settings.retClass);
                        }
                        if (settings.subject != undefined) {
                            document.getAnonymousElementByAttribute(this, "anonid", "subjectvalue").value = settings.subject;
                            this.setAttribute('subject', settings.subject);
                        }
                        if (settings.detail != undefined) {
                            document.getAnonymousElementByAttribute(this, "anonid", "detailvalue").value = settings.detail;
                            this.setAttribute('detail', settings.detail);
                        }
                        if (settings.description != undefined) {
                            document.getAnonymousElementByAttribute(this, "anonid", "descriptionvalue").value = settings.description;
                        }
                    }
                ]]></body>
            </method>
        </implementation>
        <content>
            <xul:vbox flex="1">
                <xul:separator class="thin" orient="horizontal"/>
                <xul:hbox align="center">
                    <xul:label anonid="automaticlabel" value="&prefPane.prefpaneAcknowledgement.settings.radiogroup.label;"/>
                    <xul:separator class="thin" orient="vertical"/>
                    <xul:radiogroup anonid="automaticoptions" orient="horizontal">
                        <xul:radio label="&prefPane.prefpaneAcknowledgement.settings.radiogroup.off;" value="0"/>
                        <xul:radio label="&prefPane.prefpaneAcknowledgement.settings.radiogroup.on;" value="1"/>
                    </xul:radiogroup>
                </xul:hbox>
                <xul:separator class="thin" orient="horizontal"/>
                <xul:separator class="thin" orient="horizontal"/>
                <xul:grid flex="1">
                    <xul:columns>
                        <xul:column/>
                        <xul:column flex="1"/>
                    </xul:columns>
                    <xul:rows>
                        <xul:row align="center">
                            <xul:label anonid="statuslabel" value="&prefPane.prefpaneAcknowledgement.settings.status.label;"/>
                            <xul:menulist align="stretch" anonid="statusvalue">
                                <xul:menupopup align="stretch">
                                    <xul:menuitem label="&prefPane.prefpaneAcknowledgement.settings.status.ack;" value="ACK"/>
                                    <xul:menuitem label="&prefPane.prefpaneAcknowledgement.settings.status.nak;" value="NAK"/>
                                </xul:menupopup>
                            </xul:menulist>
                        </xul:row>
                        <xul:row align="center">
                            <xul:label anonid="classlabel" value="&prefPane.prefpaneAcknowledgement.settings.class;"/>
                            <xul:textbox align="stretch" anonid="classvalue" multiline="false" placeholder="&prefPane.prefpaneAcknowledgement.settings.class;"/>
                        </xul:row>
                        <xul:row align="center">
                            <xul:label anonid="subjectlabel" value="&prefPane.prefpaneAcknowledgement.settings.subject;"/>
                            <xul:textbox align="stretch" anonid="subjectvalue" multiline="false" placeholder="&prefPane.prefpaneAcknowledgement.settings.subject;"/>
                        </xul:row>
                        <xul:row align="center">
                            <xul:label anonid="detaillabel" value="&prefPane.prefpaneAcknowledgement.settings.detail;"/>
                            <xul:textbox align="stretch" anonid="detailvalue" multiline="false" placeholder="&prefPane.prefpaneAcknowledgement.settings.detail;"/>
                        </xul:row>
                        <xul:row flex="1">
                            <xul:vbox align="start">
                                <xul:separator class="thin" orient="horizontal"/>
                                <xul:box align="center">
                                    <xul:label anonid="descriptionlabel" value="&prefPane.prefpaneAcknowledgement.settings.description;"/>
                                </xul:box>
                            </xul:vbox>
                            <xul:textbox align="stretch" anonid="descriptionvalue" flex="1" multiline="true" placeholder="&prefPane.prefpaneAcknowledgement.settings.description;"/>
                        </xul:row>
                    </xul:rows>
                </xul:grid>
            </xul:vbox>
        </content>
    </binding>

    <binding id="sepamailmessagetypesettings">
        <implementation>
            <constructor><![CDATA[
                if (this.hasAttribute('messageType')) {
                    document.getAnonymousElementByAttribute(this, "anonid", "caption").label = this.getAttribute('messageType').trim();
                }
                if (this.hasAttribute('bodyXSL')) {
                    document.getAnonymousElementByAttribute(this, "anonid", "bodyXSLvalue").value = this.getAttribute('bodyXSL');
                }
                if (this.hasAttribute('hasAttachment')) {
                    let isTrue = (this.getAttribute('hasAttachment') === 'true');
                    if (isTrue) {
                        document.getAnonymousElementByAttribute(this, "anonid", "hasAttachments").checked = true;
                    } else {
                        document.getAnonymousElementByAttribute(this, "anonid", "hasAttachments").checked = false;
                    }
                }
            ]]></constructor>
            <property name="bodyXSL">
                <getter><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", "bodyXSLvalue").value.trim();
                ]]></getter>
                <setter><![CDATA[
                    if (val) {
                        document.getAnonymousElementByAttribute(this, "anonid", "bodyXSLvalue").value = val.trim();
                        this.setAttribute('bodyXSL', val.trim());
                    }
                ]]></setter>
            </property>
            <property name="hasAttachments">
                <getter><![CDATA[
                    return document.getAnonymousElementByAttribute(this, "anonid", "hasAttachments").checked;
                ]]></getter>
                <setter><![CDATA[
                    let isTrue = (val === 'true');
                    if (isTrue) {
                        document.getAnonymousElementByAttribute(this, "anonid", "hasAttachments").checked = true;
                    } else {
                        document.getAnonymousElementByAttribute(this, "anonid", "hasAttachments").checked = false;
                    }
                ]]></setter>
            </property>
            <property name="settings" readonly="true">
                <getter><![CDATA[
                    return {
                        "body": document.getAnonymousElementByAttribute(this, "anonid", "bodyXSLvalue").value.trim(),
                        "hasAttachments": document.getAnonymousElementByAttribute(this, "anonid", "hasAttachments").checked
                    }
                ]]></getter>
            </property>
        </implementation>
        <content>
            <xul:groupbox flex="1">
                <xul:caption anonid="caption"/>
                <xul:vbox flex="1">
                    <xul:separator class="thin" orient="horizontal"/>
                    <xul:grid flex="1">
                        <xul:columns>
                            <xul:column flex="1"/>
                        </xul:columns>
                        <xul:rows>
                            <xul:row>
                                <xul:label value="&prefPane.prefpaneAdvanced.tab.messageType.body.label;"/>
                            </xul:row>
                            <xul:row flex="1">
                                <xul:textbox align="stretch" anonid="bodyXSLvalue" flex="1" multiline="true" placeholder="&prefPane.prefpaneAdvanced.tab.messageType.body.placeholder;"/>
                            </xul:row>
                            <xul:row align="center">
                                <xul:checkbox anonid="hasAttachments" label="&prefPane.prefpaneAdvanced.tab.messageType.attachments.label;"/>
                            </xul:row>
                        </xul:rows>
                    </xul:grid>
                </xul:vbox>
            </xul:groupbox>
        </content>
    </binding>

</bindings>